# bitcoin 白皮书
## 摘要
### 比特币是一种不需要第三方支持的点对点电子现金支付系统。
### 主要问题：
    去中心化的p2p系统
    解决支付双花的问题

### 为什么区块链称为链？
    比特币引入了基于时间戳的随机散列，并且让其形成前后文相关的序列
### 账本不可更改
    除非重新完成全部的工作量证明，形成的交易记录将不可更改

## 简介
### 缺陷
    比特币缺乏不可逆缺陷。这里面需要注意的是比特币系统代替的是中心化中介的信用，并不能保证交易双方的信用，相反一旦交易的某一方出现信用问题这笔交易是无法撤销的，对于初次接触比特币的人一定要尤为注意，也就是说和传统银行交易不同，一旦你确定支付，哪怕对方是骗了你，你的交易损失是无法追回的。
### 比特币解释
    一种电子支付系统，它基于密码学原理而不基于信用，使得任何达成一致的双方，能够直接进行支付，从而不需要第三方中介的参与。杜绝回滚(reverse)支付交易的可能，这就可以保护特定的卖家免于欺诈；而对于想要保护买家的人来说，在此环境下设立通常的第三方担保机制也可谓轻松加愉快。

## transaction
### 定义：
    一枚电子货币（an electronic coin）是这样的一串数字签名：每一位所有者通过对前一次交易和下一位拥有者的公钥(Public key) 签署一个随机散列的数字签名，并将这个签名附加在这枚电子货币的末尾，电子货币就发送给了下一位所有者。而收款人通过对签名进行检验，就能够验证该链条的所有者。

### 结构：
    比特币的交易需要引入reference之前的交易用于证明有足够的输入比特币用于支出，比特币的交易记录方式是一个基于时间序列的链式结构。判断是否有足够的输入用于支付则需要矿工来判断。

### 私钥：自己知道，用来签名。
    私钥本质上是随机数。
### 公钥：所有人都可以知道，用来验证签名。
    公钥是由私钥生成的，通过椭圆曲线(ECPoint)生成，一个私钥经过椭圆曲线变换之后能够得到公钥。
### 地址：比特币钱包地址。
    公钥太长了，所以就有更短一些的地址的概念，另一方面没有发送过交易的地址，并不想暴露自己的公钥，而地址是通过摘要算法生成的,不会暴露公钥的真实内容。

## 货币支付过程
   
    假设：每个人的地址为公钥。
    示例：小兰付给小明2个比特币。
    Step1: 
        首先查看当前图中的交易内容：交易内容，前一条交易的地址，小明公钥，使用小兰私钥加密（交易内容，前一条交易的地址，小明公钥）之后的数字签名，以及小兰的公钥。
    Step2: 
        小兰通过P2P技术将当前交易发送给小明。
    Step3:
        a) 小明首先使用小兰公钥将小兰签名进行解密得到hash值。
        b) 小明加密交易内容，前一条交易的地址和小明自己的公钥得到hash值。
        c）对比两个hash值，判断是否来自小兰。

### 交易记录中包含前一条交易的地址，用于reference以前的记录。

### 双重支付的问题
    首先所有的交易全网都是公开的，所有人都可以追溯交易的来龙去脉。
    二是每笔交易都有时间戳，具有先后顺序，形成时间序列交易链。证明前一条有效即可，则后面的无效。
    三是，假如有人说那我通过特有的方式创造了相同时间戳的双重支付记录。那么就会产生分叉，分叉的最终结果还是取最长的链，只会有一条记录记录在区块链上。


### 如何判断用户当前有足够的比特币用于支付
    矿工工作：确认时首先要确认之前reference的这笔交易是否存在，同时还要检查在这之前有没有将比特币支付过了。这一切确认后，这笔交易有效性就被确认了。

## 时间戳
### 时间戳的意义
    时间戳的意义在于避免双重支付问题，时间戳的单位是块。块的生成需要矿工的工作，后面再看。这里直接先说时间戳。
    A timestamp server works by taking a hash of a block of items to be timestamped and widely publishing the hash, such as in a
    newspaper or Usenet post [2-5].

    感觉网上中文翻译怪怪的： 时间戳服务器通过对以区块(block)形式存在的一组数据实施随机散列而加上时间戳。
    我看了这个就纠结于随即散列是个啥意思？
    a hash of a block of items：多条交易构成块的hash值。
    to be timestamped：具有时间戳含义。
    我的理解是：时间戳通过多条交易构成块的hash具有时间戳含义并且将当前hash广播出去，当前hash代表当前区块。

    当前hash值具有时间戳含义通过区块hash的计算就可以知道了：https://blog.csdn.net/It_rod/article/details/83155064#t7前面文章也有介绍，区块的hash计算如下。
    func calculateHash(block Block) string {
        data := string(block.Index) + string(block.TimeStamp) + block.PrevBlockHash + block.Data
        blockInBytes := sha256.Sum256([]byte(data))
        return hex.EncodeToString(blockInBytes[:])
    }   

### 如何避免双重支付
    前面内容了解到区块的hash具有时间戳。现在假设两条交易在同一区块，则验证第一条有效之后，第二条则无效。
    如果在不同区块，则区块具有时间戳，前面区块的交易有效之后，第二条记录则无效。
    如果碰到区块分叉，则最终只会有一个区块会成功上链，也不会出现双重支付。

### 时间戳的计算
    因为区块的产生是不同矿工工作出来的，那么时间戳以谁为准呢？
    “多数人的正义”，时间来自于连接的其他节点（node）时间的中位数（mean，是个数学概念，比平均值更不受极端数字影响），要求连接的节点（node）数量至少为5，中位数和本地系统时间差别不超过70分钟，否则会提醒你更新本机的时间。同时，在接收到新的block时会拒绝时间与自己差距+2小时和-(前11个block时间中位数)的block

### 中位数
